# Sass Advanced
## Sass 常用命令
	--更新 sass ==> gem update sass
	--查看 sass 版本 ==> sass -v
	--查看 sass 帮助 ==> sass -h
	--测试 SassScript 的功能 ==> sass -i

## 命令行编译
	--单文件转换命令 ==> sass style.scss style.css
	--单文件监听命令 ==> sass --watch style.scss:style.css
	--如果你有很多的sass文件的目录，你也可以告诉sass监听整个目录 ==> sass --watch app/sass:public/stylesheets

## 命令行编译配置选项
	--编译格式 ==> sass --watch style.scss:style.css --style compact
	--编译添加调试 map ==> sass --watch style.scss:style.css --sourcemap
	--选择编译格式并添加调试 map ==> sass --watch style.scss:style.css --style expanded --sourcemap
	--开启 debug 信息 ==> sass --watch input.scss:style.css --debug-info
	 *--style表示解析后的css是什么排版格式;sass内置有四种编译格式:nested``expanded(正常)``compact(压缩)``compressed.
	 *--sourcemap表示开启sourcemap调试。开启sourcemap调试后，会生成一个后缀名为.css.map文件.

## 文档
### 插值语句 (interpolation) 也可写进多行注释中输出变量值
	$version: "1.2.3";
	/* This CSS is generated by My Snazzy Framework version #{$version}. */
	
	==> 编译为
	
	/* This CSS is generated by My Snazzy Framework version 1.2.3. */

### SassScript
	--SassScript 可作用于任何属性,允许属性使用变量、算数运算等额外功能.
	--通过 interpolation(插值语句),SassScript 甚至可以生成选择器或属性名,这一点对编写 mixin 有很大帮助.
	 **插值语句编译都会出错,网上搜不到解决方法.待后续研究(原因是 .scss 格式 写成了 .sass, 造成编译出错).
#### Interactive Shell
	--Interactive Shell 可以在命令行中测试 SassScript 的功能.
	--在命令行中输入 sass -i,然后输入想要测试的 SassScript 查看输出结果.
#### 变量 $ (Variables: $)
	--将局部变量转换为全局变量可以添加 !global 声明.
#### 数据类型 (Data Types)
	--Sass 对于属性值一律视为无引号字符串.
##### 字符串 (Strings)
	--有引号字符串与无引号字符串,
	--例外: 使用 #{} (interpolation) 时,有引号字符串将被编译为无引号字符串,这样便于在 mixin 中引用选择器名.(文档例子编译
	 出错==> 原因是 .scss 格式 写成了 .sass, 造成编译出错).
##### 示例
	@mixin firefox-message($selector) {
	  body.firefox #{$selector}:before {
	    content: "Hi, Firefox users!";
	  }
	}
	@include firefox-message(".header");
	
	==> 编译为
	
	body.firefox .header:before {
	  content: "Hi, Firefox users!"; 
	}

### @-Rules 与指令
#### @import
	--在以下情况下,@import 仅作为普通的 CSS 语句,不会导入任何 Sass 文件:
	 1、文件拓展名是 .css;
	 2、文件名以 http:// 开头;
	 3、文件名是 url();
	 4、@import 包含 media queries.
	--Sass 允许同时导入多个文件,文件之间用','隔开.
	
#### @media
	--Sass 中 @media 指令与 CSS 中用法一样,只是增加了一点额外的功能: 允许其在 CSS 规则中嵌套.
	--如果 @media 嵌套在 CSS 规则内,编译时,@media 将被编译到文件的最外层,包含嵌套的父选择器.
	--@media 的 queries 允许互相嵌套使用,编译时,Sass 自动添加 and.
	--@media 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值(可以编译).
##### 示例
	.sidebar {
	  @media screen and (orientation: landscape) {
	    width: 500px;
	  }
	}
	或
	@media screen {
	  .sidebar {
	    @media (orientation: landscape) {
	      width: 500px;
	    }
	  }
	}
	
	==>
	
	@media screen and (orientation: landscape) {
	  .sidebar {
	    width: 500px;
	  }
	}

#### @extend
	--多重延伸
	 同一个选择器可以延伸给多个选择器,它所包含的属性将继承给所有被延伸的选择器.
	--继续延伸
	 当一个选择器延伸给第二个后，可以继续将第二个选择器延伸给第三个.
	--选择器列
	 暂时不可以将选择器列,比如 .foo .bar 或 .foo + .bar，延伸给其他元素,但是,却可以将其他元素延伸给选择器列.
	--合并选择器列
	 有时会遇到复杂的情况,比如选择器列中的某个元素需要延伸给另一个选择器列,这种情况下,两个选择器列需要合并.
		1、当两个列 (sequence) 合并时,如果没有包含相同的选择器,将生成两个新选择器: 第一列出现在第二列之前，或者第二列出
	 现在第一列之前;
	  2、如果两个列 (sequence) 包含了相同的选择器,相同部分将会合并在一起,其他部分交替输出.

#### @extend-Only 选择器
	--引入了“占位符选择器” (placeholder selectors),看起来很像普通的 id 或 class 选择器,只是 # 或 . 被替换成了 %.可以
	 像 class 或者 id 选择器那样使用,当它们单独使用时,不会被编译到 CSS 文件中.
	--如果要求 @extend 不生成新选择器,可以通过 !optional 声明达到这个目的.(不太理解!!)
	--在指令中延伸
	 如果在 @media(或者其他 CSS 指令)中使用 @extend,必须延伸给相同指令层中的选择器.
##### 示例
	#context a%extreme {
	  color: blue;
	  font-weight: bold;
	  font-size: 2em;
	}
	.notice {
	  @extend %extreme;
	}
	
	==> 编译为
	
	#context a.notice {
	  color: blue;
	  font-weight: bold;
	  font-size: 2em; 
	}

#### @at-root
	--@at root指令导致在文档的根目录下发出一个或多个规则,而不是嵌套在其父选择器下.它可以与单个内联选择器一起使用.
	--默认情况下,@at root只排除选择器.但是,也可以使用@at root移动到嵌套指令（如@media）之外.
	 @at-root (without: ...) and @at-root (with: ...)
##### 示例
	.parent {
	  @at-root {
	    .child1 { color: #111; }
	    .child2 { color: #222; }
	  }
	  .step-child { color: #333; }
	}
	
	==> 编译为
	.child1 {
	  color: #111; 
	}
	.child2 {
	  color: #222; 
	}
	.parent .step-child {
	  color: #333; 
	}
	
#### @debug
	--@debug指令将sassscript表达式的值打印到标准错误输出流.它对于调试sass文件非常有用.
	
#### @warn
	--@warn指令将sassscript表达式的值打印到标准错误输出流.它对于需要警告用户不赞成或从mixin使用错误中恢复的库非常有用.
	--@warn和@debug之间有两个主要区别:
	 1、可以使用--quiet命令行选项或: quiet sass 选项关闭警告.
	 2、样式表跟踪将与消息一起打印出来,以便被警告的用户可以看到他们的样式导致警告的位置.
	 
#### @error
	--@error指令将sassscript表达式的值作为致命错误抛出,包括一个良好的堆栈跟踪.它对于验证mixin和函数的参数很有用.
##### 示例
	@mixin adjust-location($x, $y) {
	  @if unitless($x) {
	    @error "$x may not be unitless, was #{$x}.";
	  }
	  @if unitless($y) {
	    @error "$y may not be unitless, was #{$y}.";
	  }
	  position: relative; left: $x; top: $y;
	}
	.demo {
		@include adjust-location(1px, 2px); //无参数或参数不带单位就会报错.
	}
	
	==> 编译为
	
	.demo {
	  position: relative;
	  left: 1px;
	  top: 2px; 
	}